using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using NinMods.Bot;
using NinMods.Logging;

namespace NinMods
{
    public static class GameExploits
    {
        // ignore the out parameters, just trying to consolidate as much of the exploit logic as possible in this one method
        public static bool Movement(Stack<Vector2i> path, out Vector2i botLocation, out Vector2i tileDirection)
        {
            botLocation = new Vector2i();
            tileDirection = new Vector2i();
            // exploit:
            // we should be checking if tmr25 AND player.Moving (which is set according to player.xOffet and player.yOffset iirc) are valid
            // but the server lets us get away with just checking tmr25
            if (client.modGlobals.tmr25 >= client.modGlobals.Tick)
                return true;

            botLocation = BotUtils.GetSelfLocation();
            Vector2i nextTile = path.Pop();
            tileDirection = nextTile - botLocation;

            byte gameDir = 255;
            for (int index = 0; index < Vector2i.directions_Eight.Length; index++)
                if (tileDirection == Vector2i.directions_Eight[index])
                    gameDir = (byte)index;

            if (gameDir == 255)
            {
                Logger.Log.WriteError($"Could not get direction out of {tileDirection} (self: {botLocation}; nextTile: {nextTile})");
                return false;
            }
            Logger.Log.Write($"Moving bot from {botLocation} to {nextTile} in direction {gameDir} (tileDir: {tileDirection})", Logger.ELogType.Info, null, true);
            // perform next movement
            // set state before sending packet
            client.modTypes.Player[client.modGlobals.MyIndex].Dir = gameDir;
            // NOTE:
            // the game has a value (3) for MOVING_DIAGONAL but doesn't seem to implement it anywhere. in fact, using it will cause movement to break.
            client.modTypes.Player[client.modGlobals.MyIndex].Moving = Constants.MOVING_RUNNING;
            client.modTypes.Player[client.modGlobals.MyIndex].Running = true;
            // send state to server
            client.modClientTCP.SendPlayerMove();
            // client-side prediction
            client.modTypes.Player[client.modGlobals.MyIndex].xOffset = System.Math.Abs(tileDirection.x * 32f);
            client.modTypes.Player[client.modGlobals.MyIndex].yOffset = System.Math.Abs(tileDirection.y * 32f);
            client.modTypes.Player[client.modGlobals.MyIndex].X = (byte)(botLocation.x + tileDirection.x);
            client.modTypes.Player[client.modGlobals.MyIndex].Y = (byte)(botLocation.y + tileDirection.y);
            Logger.Log.Write($"Predicted: ({client.modTypes.Player[client.modGlobals.MyIndex].X}, " +
                $"{client.modTypes.Player[client.modGlobals.MyIndex].Y}) (offset: " +
                $"{client.modTypes.Player[client.modGlobals.MyIndex].xOffset}, " +
                $"{client.modTypes.Player[client.modGlobals.MyIndex].yOffset})");
            return true;
        }

        public static void CollectItem()
        {
            Logger.Log.Write("Trying to collect item multiple times");
            client.clsBuffer clsBuffer2 = new client.clsBuffer();
            clsBuffer2.WriteLong(31);
            byte[] payload = clsBuffer2.ToArray();
            for (int num = 0; num < 10; num++)
            {
                client.modClientTCP.SendData(payload);
            }
        }
    }
}
